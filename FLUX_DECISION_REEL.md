# FLUX DE D√âCISION R√âEL - Architecture Microservices

## üéØ Flux Actuellement Impl√©ment√©

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Market Analyzer ‚îÇ ‚Üí Calcule 106 indicateurs ‚Üí PostgreSQL (analyzer_data)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì Redis PubSub: "analyzer_trigger"

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Analyzer     ‚îÇ ‚Üí Ex√©cute 28 strat√©gies sur les indicateurs
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì Redis PubSub: "analyzer:signals"

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇSignal Aggregator ‚îÇ ‚Üí Consensus multi-strat√©gies
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì Redis PubSub: "roottrading:signals:filtered"

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Coordinator    ‚îÇ ‚Üí D√âCISION FINALE BUY/SELL/AVOID
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì HTTP: trader:5002/orders

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Trader      ‚îÇ ‚Üí Ex√©cution Binance
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üìä Analyzer - 28 Strat√©gies Existantes

**Fichier**: `analyzer/src/main.py` (802 lignes)

### Strat√©gies Charg√©es Automatiquement

**Trend-Based (7)**:
- EMA_Cross_Strategy
- HullMA_Slope_Strategy
- TEMA_Slope_Strategy
- Supertrend_Reversal_Strategy
- VWAP_Support_Resistance_Strategy
- ADX_Direction_Strategy
- ParabolicSAR_Bounce_Strategy

**Momentum-Based (8)**:
- RSI_Cross_Strategy
- MACD_Crossover_Strategy
- Stochastic_Oversold_Buy_Strategy
- StochRSI_Rebound_Strategy
- CCI_Reversal_Strategy
- ROC_Threshold_Strategy
- WilliamsR_Rebound_Strategy
- PPO_Crossover_Strategy

**Volatility-Based (4)**:
- Bollinger_Touch_Strategy
- ATR_Breakout_Strategy
- Donchian_Breakout_Strategy
- zscore_extreme_reversal_strategy

**Support/Resistance (4)**:
- Support_Breakout_Strategy
- Resistance_Rejection_Strategy
- Range_Breakout_Confirmation_Strategy
- Liquidity_Sweep_Buy_Strategy

**Volume-Based (2)**:
- OBV_Crossover_Strategy
- Spike_Reaction_Buy_Strategy

**Advanced (4)**:
- MultiTF_ConfluentEntry_Strategy
- Pump_Dump_Pattern_Strategy
- TRIX_Crossover_Strategy

### Processus Analyzer

```python
# analyzer/src/main.py:481-594
async def analyze_symbol_timeframe(self, symbol: str, timeframe: str):
    # 1. R√©cup√©rer donn√©es depuis analyzer_data (106 indicateurs)
    market_data = self.fetch_latest_data(symbol, timeframe)

    # 2. Ex√©cuter les 28 strat√©gies
    strategies = self.strategy_loader.get_all_strategies()
    signals = []

    for strategy_name, strategy_class in strategies.items():
        # Instancier strat√©gie avec indicateurs
        strategy = strategy_class(
            symbol=symbol,
            data=market_data["data"],
            indicators=market_data["indicators"]
        )

        # G√©n√©rer signal BUY/SELL
        signal = strategy.generate_signal()

        if signal["side"]:  # Si signal g√©n√©r√©
            signal_data = {
                "symbol": symbol,
                "timeframe": timeframe,
                "strategy": strategy_name,
                "side": signal["side"],
                "confidence": signal["confidence"],
                "strength": signal["strength"],
                "reason": signal["reason"],
                "metadata": signal["metadata"]
            }
            signals.append(signal_data)

    # 3. Publier signaux individuels sur Redis
    if signals:
        await self.redis_publisher.publish_signals(signals, mode="individual")
```

**Output**: 0-28 signaux par symbol/timeframe selon conditions de march√©

## üîÑ Signal Aggregator - Consensus Multi-Strat√©gies

**Fichier**: `signal_aggregator/src/signal_aggregator_simple.py` (452 lignes)

### Processus de Consensus

```python
# signal_aggregator/src/signal_aggregator_simple.py:160-239
async def _process_signal_batch_simple(self, signals: list):
    # 1. Grouper par symbol + side
    signal_groups = {}
    for signal in signals:
        key = f"{signal['symbol']}_{signal['side']}"
        signal_groups[key].append(signal)

    # 2. R√©soudre conflits BUY vs SELL (syst√®me de vague)
    resolved_groups = self._resolve_simultaneous_conflicts(signal_groups)

    # 3. Valider chaque groupe
    for group_key, group_signals in resolved_groups.items():
        await self._validate_signal_group(group_signals)
```

### Validation et Consensus

```python
# signal_aggregator/src/signal_aggregator_simple.py:281-331
async def _validate_signal_group(self, signals: list):
    symbol = signals[0]["symbol"]
    side = signals[0]["side"]

    # 1. V√©rifier contradictions r√©centes (30s window)
    if self._check_recent_contradiction(symbol, side):
        return  # Bloquer

    # 2. Validation avec consensus adaptatif
    validated_signal = await self.signal_processor.validate_signal_group(
        signals, symbol, timeframe, side
    )

    if validated_signal:
        # 3. Envoyer signal consensus au Coordinator
        await self._send_validated_signal(validated_signal)

        # Format du signal consensus:
        # {
        #     "symbol": "BTCUSDC",
        #     "side": "BUY",
        #     "price": 43250.5,
        #     "metadata": {
        #         "strategies_count": 12,  # Nombre de strat√©gies en accord
        #         "consensus_strength": 8.5,  # Force du consensus
        #         "avg_confidence": 0.75,  # Confiance moyenne
        #         "type": "CONSENSUS"
        #     }
        # }
```

**Output**: Signal de consensus avec metadata enrichie

## üéØ Coordinator - D√âCISION FINALE

**Fichier**: `coordinator/src/coordinator.py` (1434 lignes)

### Points de D√©cision Principaux

#### 1. Calcul de Force du Signal

```python
# coordinator/src/coordinator.py:199-261
def _calculate_unified_signal_strength(self, signal: StrategySignal) -> tuple[float, int, float]:
    """
    Calcule la force du signal √† partir du consensus.

    Formule: Force = consensus_strength √ó ‚àö(strategies_count) √ó avg_confidence

    Returns:
        (force, strategy_count, avg_confidence)
    """
    consensus_strength = signal.metadata.get("consensus_strength", 0)
    strategies_count = signal.metadata.get("strategies_count", 1)
    avg_confidence = signal.metadata.get("avg_confidence", 0.5)

    if consensus_strength > 0 and strategies_count > 1:
        force = consensus_strength * (strategies_count ** 0.5) * avg_confidence
        return force, strategies_count, avg_confidence

    # Fallback pour signaux simples
    return 1.0, 1, 0.5
```

#### 2. Cat√©gorisation de Force

```python
# coordinator/src/coordinator.py:263-282
def _categorize_signal_strength(self, force: float) -> str:
    """
    Cat√©gories bas√©es sur la force calcul√©e:
    - VERY_STRONG: force ‚â• 12.0
    - STRONG: force ‚â• 8.0
    - MODERATE: force ‚â• 4.0
    - WEAK: force < 4.0
    """
    if force >= 12.0:
        return "VERY_STRONG"
    elif force >= 8.0:
        return "STRONG"
    elif force >= 4.0:
        return "MODERATE"
    else:
        return "WEAK"
```

#### 3. D√©cision BUY - Consensus Override

```python
# coordinator/src/coordinator.py:420-451
# CONSENSUS BUY OVERRIDE: Bypass hyst√©r√©sis pour signaux forts
if signal.side == OrderSide.BUY:
    signal_force, strategy_count, avg_confidence = (
        self._calculate_unified_signal_strength(signal)
    )

    # Seuils: force ‚â• 2.0 ET strategies ‚â• 5
    if signal_force >= 2.0 and strategy_count >= 5:
        logger.warning(f"üöÄ CONSENSUS BUY FORT d√©tect√© pour {signal.symbol}")

        # Forcer l'ajout √† l'univers tradable pour 45 minutes
        self.universe_manager.force_pair_selection(
            signal.symbol, duration_minutes=45
        )
```

#### 4. Allocation Dynamique selon Force

```python
# coordinator/src/coordinator.py:786-828
# Allocation bas√©e sur la cat√©gorie de force
if strength_category == "VERY_STRONG":
    allocation_percent = 28.0  # 28% de l'USDC disponible
elif strength_category == "STRONG":
    allocation_percent = 22.0  # 22% de l'USDC disponible
elif strength_category == "MODERATE":
    allocation_percent = 18.0  # 18% de l'USDC disponible
else:  # WEAK
    allocation_percent = 12.0  # 12% de l'USDC disponible

# Calculer montant √† trader
trade_amount = usdc_balance * (allocation_percent / 100)

# Convertir en quantit√©
quantity = trade_amount / signal.price
```

#### 5. D√©cision SELL - Consensus Override

```python
# coordinator/src/coordinator.py:283-351
def _check_consensus_sell_override(self, signal: StrategySignal, entry_price: float):
    """
    V√©rifie si un consensus SELL fort doit bypasser le trailing stop.

    Conditions:
    - Type = CONSENSUS
    - Strategies ‚â• 4
    - Force ‚â• 1.8
    - Perte actuelle < -0.6 √ó ATR%
    """
    signal_force, strategies_count, avg_confidence = (
        self._calculate_unified_signal_strength(signal)
    )

    # Calculer perte actuelle
    current_loss_pct = ((signal.price - entry_price) / entry_price) * 100

    # R√©cup√©rer ATR dynamique
    atr_pct = self.trailing_manager._get_atr_percentage(signal.symbol)
    loss_threshold = -0.6 * atr_pct

    # Forcer vente si conditions remplies
    if (signal_type == "CONSENSUS" and
        strategies_count >= 4 and
        signal_force >= 1.8 and
        current_loss_pct < loss_threshold):

        return True, f"CONSENSUS_SELL_FORCED: {strategies_count} strat√©gies, force {signal_force:.1f}"

    return False, "Conditions non remplies"
```

### Filtres de Faisabilit√©

```python
# coordinator/src/coordinator.py:575-706
def _check_feasibility(self, signal: StrategySignal) -> tuple[bool, str]:
    """
    V√©rifie si le trade est faisable:

    Pour BUY:
    1. Paire dans l'univers tradable ? (UniverseManager)
    2. USDC suffisant ? (‚â• 15 USDC minimum)
    3. Pas de cycle actif pour ce symbole ?

    Pour SELL:
    1. Trailing stop autorise vente ? (TrailingSellManager)
    2. Ou consensus SELL fort bypass trailing ?
    3. Balance crypto suffisante ?
    4. Valeur ‚â• 15 USDC ?
    """
```

## üìà D√©cisions Finales Prises par Coordinator

### BUY Decision Tree

```
Signal BUY re√ßu
    ‚Üì
Force calcul√©e ‚Üí Cat√©gorisation (VERY_STRONG/STRONG/MODERATE/WEAK)
    ‚Üì
Force ‚â• 2.0 ET strategies ‚â• 5 ?
    ‚îú‚îÄ OUI ‚Üí Ajout forc√© √† l'univers tradable (45min)
    ‚îî‚îÄ NON ‚Üí V√©rifier univers normal
         ‚Üì
Paire dans univers tradable ?
    ‚îú‚îÄ NON ‚Üí REJECT
    ‚îî‚îÄ OUI ‚Üí USDC ‚â• 15 ?
         ‚îú‚îÄ NON ‚Üí Tenter vente pire position
         ‚îî‚îÄ OUI ‚Üí Pas de cycle actif ?
              ‚îú‚îÄ Cycle existe ‚Üí REJECT
              ‚îî‚îÄ Pas de cycle ‚Üí BUY AUTORIS√â
                   ‚Üì
              Allocation = f(force):
              - VERY_STRONG ‚Üí 28% USDC
              - STRONG ‚Üí 22% USDC
              - MODERATE ‚Üí 18% USDC
              - WEAK ‚Üí 12% USDC
```

### SELL Decision Tree

```
Signal SELL re√ßu
    ‚Üì
Position active existe ?
    ‚îú‚îÄ NON ‚Üí SELL AUTORIS√â (nettoyage)
    ‚îî‚îÄ OUI ‚Üí Consensus SELL fort ?
         ‚îú‚îÄ OUI (‚â•4 strat, force ‚â•1.8, perte < -0.6√óATR%)
         ‚îÇ    ‚Üí SELL FORC√â (bypass trailing)
         ‚îî‚îÄ NON ‚Üí Trailing stop autorise ?
              ‚îú‚îÄ NON ‚Üí REJECT (continuer trailing)
              ‚îî‚îÄ OUI ‚Üí Balance crypto ‚â• 15 USDC ?
                   ‚îú‚îÄ NON ‚Üí REJECT
                   ‚îî‚îÄ OUI ‚Üí SELL AUTORIS√â
```

## üîß Utilisation R√âELLE des 106 Indicateurs

### Par les 28 Strat√©gies

Chaque strat√©gie utilise **3-10 indicateurs** parmi les 106 disponibles:

Exemple `EMA_Cross_Strategy`:
- `ema_12`, `ema_26` (moyennes mobiles)
- `rsi_14` (momentum)
- `volume_ratio` (confirmation)

Exemple `VWAP_Support_Resistance_Strategy`:
- `vwap_10`, `vwap_quote_10`
- `nearest_support`, `nearest_resistance`
- `support_strength`, `resistance_strength`

**R√©sultat**: Les 28 strat√©gies utilisent **collectivement ~80% des 106 indicateurs**

### Par le Coordinator

Le Coordinator utilise **seulement les m√©tadonn√©es du consensus**:
- `consensus_strength`
- `strategies_count`
- `avg_confidence`

Il ne lit **JAMAIS directement** les 106 indicateurs de la DB.

## ‚öñÔ∏è Comparaison avec le Syst√®me v5.0 de Visualization

| Aspect | Microservices (Analyzer‚ÜíAggregator‚ÜíCoordinator) | Visualization v5.0 |
|--------|------------------------------------------------|-------------------|
| **Indicateurs DB utilis√©s** | ~85 sur 106 (80%) via 28 strat√©gies | 25 sur 106 (24%) directement |
| **Logique de d√©cision** | Consensus multi-strat√©gies ‚Üí Force ‚Üí Allocation | Scoring direct 9 cat√©gories ‚Üí Seuil |
| **D√©cision BUY** | Force consensus ‚â• 2.0 + ‚â•5 strat√©gies | Score ‚â• 70 = BUY_NOW |
| **D√©cision SELL** | Consensus ‚â•4 strat + perte < -0.6√óATR% | N/A (pas de gestion SELL) |
| **Allocation** | Dynamique 12-28% selon force | Fixe (non impl√©ment√©e) |
| **Architecture** | Distribu√©e, scalable, r√©siliente | Monolithique, simple |
| **Complexit√©** | Haute (3 services, Redis, consensus) | Faible (1 fichier Python) |

## üéØ Proposition: Utiliser le Flux Complet

### Avantages

‚úÖ **Utilisation maximale des indicateurs**: 80% vs 24%
‚úÖ **28 strat√©gies d√©j√† cod√©es et test√©es**: Ne pas r√©inventer la roue
‚úÖ **Consensus intelligent**: Agr√©gation multi-strat√©gies robuste
‚úÖ **Allocation dynamique**: 12-28% selon force du signal
‚úÖ **Architecture scalable**: Pr√™te pour production
‚úÖ **Trailing stop int√©gr√©**: Gestion intelligente des sorties

### D√©sactivation des 4 Fichiers Python Visualization

Fichiers √† d√©sactiver:
1. `visualization/backend/opportunity_scoring_v5.py`
2. `visualization/backend/opportunity_calculator_pro.py`
3. `visualization/backend/opportunity_validator.py`
4. `visualization/backend/opportunity_early_detector.py`

### Nouvelle Connexion Visualization

```python
# Au lieu de calculer localement:
# score = opportunity_scoring_v5.calculate_score(data)

# √âcouter les d√©cisions du Coordinator:
redis.subscribe("roottrading:signals:filtered")

# Afficher les signaux de consensus:
{
    "symbol": "BTCUSDC",
    "side": "BUY",
    "action": "BUY_NOW",  # Calcul√© par Coordinator
    "allocation": "28%",  # VERY_STRONG
    "strategies": 12,     # Nombre de strat√©gies en accord
    "force": 15.2,        # Force du consensus
    "confidence": 0.82    # Confiance moyenne
}
```

## üìù Prochaines √âtapes

1. ‚úÖ Analyser le flux existant (FAIT)
2. üîÑ Documenter les points de d√©cision (EN COURS)
3. ‚è≥ Cr√©er configuration pour d√©sactiver v5.0 Visualization
4. ‚è≥ Adapter frontend pour afficher signaux Coordinator
5. ‚è≥ Tester le flux complet avec les 28 strat√©gies
6. ‚è≥ Comparer performance v5.0 vs Microservices

## üí° Conclusion

Le syst√®me **Analyzer ‚Üí Signal Aggregator ‚Üí Coordinator** est d√©j√† **complet et op√©rationnel**.

Il utilise:
- ‚úÖ 28 strat√©gies professionnelles
- ‚úÖ ~85 indicateurs sur 106 (80% de la DB)
- ‚úÖ Consensus multi-strat√©gies intelligent
- ‚úÖ Allocation dynamique selon force
- ‚úÖ Gestion trailing stop adaptative
- ‚úÖ Architecture microservices scalable

**Recommandation**: D√©sactiver les 4 fichiers Python de Visualization et utiliser ce flux mature et complet.
